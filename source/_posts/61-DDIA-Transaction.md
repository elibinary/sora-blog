---
title: DDIA-分布式存储-事务
date: 2020-06-22 19:23:09
tags:
  - db
description: 事务的基本定义：事务中的所有读写操作被视为单个操作来执行，整个事务要么成功，要么失败回滚，不存在执行一半的情况。如果失败，应用程序可以安全的重试
---

事务的基本定义：事务中的所有读写操作被视为单个操作来执行，整个事务要么成功，要么失败回滚，不存在执行一半的情况。如果失败，应用程序可以安全的重试

思考：
1. 事务提供了哪些安全保障
2. 事务所实现的保障需要付出的代价是什么
3. 什么时候需要事务
4. 事务的优势和局限性有哪些

## ACID
著名的 ACID 标准：

* 原子性(Atomicity)
* 一致性(Consistency)
* 隔离性(Isolation)
* 持久性(Durability)

不同数据库对于 ACID 的实现并不相同，甚至含义思路也有差别

**`原子性`** 的定义特征：能够在错误发生时终止事务，并丢弃该事务所有的写入变更。原子性简化了处理操作中间状态的问题：如果事务被终止，应用程序可以确定它没改变任何东西，可以安全重试

**`一致性`** 的概念定义：对数据的一组特定陈述必须始终成立。但是，一致性的这种概念取决于应用程序对不变量的观念。
另外一致性这个词被用来很多概念里，并且含义都不尽相同，比如：复制中的副本一致性，一致性哈希以及著名的 CAP 中的一致性
简单来讲，在 ACID 的意义上一致性是应用程序的属性，粗暴来讲数据库只管存储

**`隔离性`** 是用来描述解决并发问题的：同时执行的事务是相互隔离的

**`持久性`** 顾名思义就是承诺一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的数据也不会丢失

事务的一个关键特性：如果发生错误，它可以终止并安全的重试。
ACID 基于同样的哲学：如果数据库有违反原子性、隔离性、持久性的危险，则宁愿完全放弃事务，而不是留下半成品。

## 事务隔离级别
> 四种隔离级别：
1. 读未提交
2. 读已提交
3. 可重复读
4. 可序列化

事务的竞争问题：如果两个事务不触及相同的数据，那么它们可以安全的并行执行。当一个事务读取另一个事务同时修改的数据，或两个事务同时修改相同的数据时，并发问题就出现了。

通常数据库的并发问题很难通过测试找到，也比较难以重现。因此多数数据库会提供 `事务隔离` 来隐藏应用程序开发者的并发问题。

* 弱隔离级别
* 可序列化级别

可序列化的隔离级别表示数据库保证事务的效果和连续执行（one by one）是一样的，同时它的性能损耗也将很大
所以很多数据库提供了一些不同严格程度的弱隔离级别
### 读已提交
Read Committed: 最基本的事务隔离级别，主要提供两个保证：
1. 没有脏读：只能读到已提交的数据
2. 没有脏写：只会覆盖已提交的数据

`防止脏写`：数据库实现通常使用行锁来防止脏写
`防止赃读`：一种选择是使用相同的锁，但是由于读操作会被写操作 block 导致及其影响吞吐，所以很多数据库会选择使用快照（记住旧的已提交值）的方式来实现

### 可重复度
`快照隔离` 是这个问题最常见的解决方案，主要思路：每个事务都从数据库的一致快照中读取，事务可以看到事务开始时在数据库中提交的所有数据，而不会读到该时间点之后被其他事务修改的新值

快照隔离对长时间运行的只读查询（如备份和分析）非常有用

**`快照隔离` 的实现** 首先快照隔离的关键原则是：读不阻塞写，写不阻塞读。
快照隔离的一般实现方式是利用 `多版本并发控制(MVCC)` ，数据库会并排维护一个对象的几个不同的提交版本

通常支持快照隔离的存储引擎也使用 MVCC 来实现 `读已提交`

*思考：
1. 索引如何在多版本数据库中工作*

### 防止丢失更新
当存在并发的 读取-修改-写入 模式时，可能会发生丢失更新的问题

基于此，很多数据库实现了原子写语义，比如：
```
UPDATE counters SET value = value + 1 WHERE key = 'foo';
```

原子操作通常是通过在读取对象时，获取其上的排他锁来实现的。当然还有一种方式是强制所有原子操作都在单一线程上执行。

**`CAS`**  Compare And Set
此操作的目的也是为了避免丢失更新，只有当前值从上次读取后一直未改变，才允许更新发生。
```
UPDATE counters SET value = 5 WHERE key = 'foo' AND value = 1;
```

可以发现，常用的乐观锁的 version 实现思路沿用同样的设计

### 可序列化
`可序列化(Serializability)`：通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就像他们是 one by one 执行的一样。

目前常见的实现方式：
1. 真的串行执行
2. 两相锁定(2PL, two-phase locking) 
3. 乐观并发控制技术（如可序列化的快照隔离）

#### 真的串行执行
虽然看起来串行将成为整个系统瓶颈，但是在特定约束下，真的串行执行事务已经成为可行方法：
1. 每个事务都必须小而快
2. 仅限于活跃数据可以放入内存的情况。如果事务所涉及的数据需要从磁盘加载，系统将会被极大拖慢
3. 写入吞吐必须低到能在单核 CPU 上处理，不然就必须进行事务分区
4. 跨分区事务是可行的，不过由于需要额外协调者参与，其有很大限制

#### 两相锁定(2PL)
*与之很相似的一个词是两阶段提交（2PC），它们是完全不同的两个概念*

`2PL` 提供了可序列化的性质，它可以防止所有竞争条件，包括丢失更新和写入偏差。

相比于之前防止脏写，`2PL` 对锁的要求更强：当没有写入时，允许多事务同时读取同一个对象；当对象有写入，就需要独占访问权限（排他）。

`2PL` 和 `快照隔离` 最大的区别：2PL 中写入不仅会阻塞其他写入，也会阻塞读，反之读也会阻塞写。

MySQL(InnoDB) 和 SQL Server 中的可序列化隔离使用了 2PL 方式实现。读和写的阻塞是通过为 db 中每个对象加锁（共享锁&排他锁）来实现的：

* 读事务：需要先获取共享锁，共享锁允许多事务同时持有；若该对象上有排他锁，则读事务等待（block）
* 写事务：需要先获取排他锁，若该对象上有任何锁存在，该事务都需等待
* 读写事务：读时获取共享锁，写时需要进行锁升级；升级锁和直接获取排他锁过程相同
* 事务获取锁之后，必须继续持有锁直到事务结束

两阶段锁定最大的缺点就是性能问题：
1. 获取和释放锁的开销
2. 并发性的大幅降低，慢事务对于系统影响极大
3. 由于大量使用了锁，死锁发生的频率也极大被提升，虽然数据库会自动检查并解决死锁，但是事务的重试将造成很大的浪费

#### 谓词锁和索引范围锁(间隙锁)
在上面 2PL 中还有一个重要的细节需要讨论：特殊情况下的幻读问题，一个简单的场景：
1. 事务A 进行范围查询：where date between '2019-11-12' and '2019-12-12'
2. 事务B 插入一条在此范围间的一条数据
3. 事务A 在进行下一步操作时将可能出现错误判断

简单来说就是，我们需要加锁的不是特定的对象（某一行数据），而是符合某些搜索条件的对象，此时我们就需要一个谓词锁。

但是由于检测匹配的谓词锁非常耗时，性能不佳。大多数数据库会用索引范围锁（间隙锁）来替代，间隙锁是一个简化版的谓词锁。

索引范围锁的思路是：给谓词匹配一个近似的、更大的集合来加锁，并简化匹配过程
搜索条件的近似值会被附加到其中一个索引上，当写操作更新到索引的相同部分时，会遇到共享锁并被迫等待

需要注意的是：当没有可以挂载间隙锁的索引时，数据库将退化到使用表锁。

#### 可序列化的快照隔离
`可序列化快照隔离(SSI)` serializable snapshot isolation, 这是一个相当新的算法，它提供了完整的可序列化隔离级别，同时相比快照隔离只有很小的性能损耗。

事务中的查询和写入可能存在因果依赖，当应用进行查询时，数据库不知道应用逻辑如何使用查询结果。数据库需要能够监测到结果集变更，并终止事务，有两种情况需要考虑：
1. 检测对旧 MVCC 对象版本的读取（读之前存在未提交的写入）
2. 检测影响先前读取的写入（读之后发生写入）

第一种情况：首先 MVCC 的实现，当一个事务从一致快照读时，会忽略尚未提交的任何其他事务的写入。这将可能导致 `写入偏差`。
未解决该问题，数据库需要跟踪其他被忽略的事务的写入，当事务提交时，数据库检查是否有被忽略的写入已经被提交，如果有则事务必须终止。

第二种情况：需要考虑另一个事务在读取数据之后修改数据

#### 悲观和乐观并发控制
`两阶段锁` 是一种悲观并发控制，它基于悲观原则：如果可能出错，最好等情况安全后再做其他事情。从这种意义上，串行化可谓是悲观到了极致。

`可序列化快照隔离` 是一种乐观并发控制，它基于乐观原则：即使存在潜在的危险也会继续执行，当事务进行提交时再检查是否有危险，有的话将被终止并重试

